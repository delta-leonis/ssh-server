package org.ssh.logs;

import org.ssh.managers.manager.Models;
import org.ssh.managers.manager.Pipelines;
import org.ssh.managers.manager.Services;
import org.ssh.models.Settings;
import org.ssh.models.Team;
import org.ssh.pipelines.packets.RefereePacket;
import org.ssh.pipelines.packets.WrapperPacket;
import org.ssh.services.AbstractConsumer;
import org.ssh.services.AbstractService;

import java.io.*;
import java.nio.ByteBuffer;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Optional;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;

/**
 * The {@link LogWriter} takes {@link WrapperPacket WrapperPackets} and {@link RefereePacket RefereePackets} from the
 * {@link Pipelines} and writes the to a log file following the Robocup SSL standards.
 * These recordings are saved in {@link Settings#getRecordingsFolder() this folder}
 *
 * @author Thomas Hakkers
 * @see <a href=http://robocupssl.cpe.ku.ac.th/gamelogs#binary_log_file_format>Go to this link</a> for more info on ssl logs
 */
public class LogWriter extends AbstractService {
    /** The {@link FileOutputStream} used to write the file */
    private OutputStream writer;
    /** The {@link LogWrapperConsumer consumer} that consumes the {@link WrapperPacket WrapperPackets} */
    private LogWrapperConsumer detectionWriter;
    /** The {@link LogWrapperConsumer consumer} that consumes the {@link WrapperPacket WrapperPackets} */
    private LogRefereeConsumer refereeWriter;
    /** Header for the log file, following the SSL standards */
    private static final String header = "SSL_LOG_FILE";
    /** Version 1, currently the only version available. Is written in the header of the file */
    private static final Integer version = 1;

    private boolean start = false;

    /** The queue of PipelinePackets. */
    private final Queue<byte[]> queue       = new ConcurrentLinkedQueue<>();

    /** Message types withing the SSL log standard. */
    public final static int
            MESSAGE_SSL_VISION_2010 = 2,
            MESSAGE_SSL_REFBOX_2013 = 3;

    /**
     * Creates a {@link LogWriter} with the appropriate name generated by {@link LogWriter#getCurrentFileName()}
     */
    public LogWriter(){
        this(getCurrentFileName());
    }

    /**
     * Creates a {@link LogWriter} with the given path and filename
     * @param path the path to where the log should be written
     */
    public LogWriter(String path){
        super("logwriter");
        // Get the time at which we started recording
        try {
            // Created a new filestream with the given path
            this.writer = new FileOutputStream(path);
            // Write the header, see: http://robocupssl.cpe.ku.ac.th/gamelogs#binary_log_file_format
            this.writer.write(header.getBytes());
            this.writer.write(new byte[]{0,0,0,version.byteValue()});
        } catch (IOException exception) {
            LOG.exception(exception);
        }

        // Create two consumers. One for the WrapperPackets and one for the RefereePackets.
        detectionWriter = new LogWrapperConsumer(this);
        refereeWriter = new LogRefereeConsumer(this);
        // Attach the compatible pipelines to these consumers
        attachToCompatiblePipelines();
    }

    /**
     * Adds the given byte[] message to the queue of data that has to be recorded
     * @param message The message that needs to be written in its bytesize form
     */
    public void addToQueue(byte[] message){
        queue.add(message);
    }

    /**
     * Starts the recording
     * @return the {@link LogWriter} for method chaining
     */
    public LogWriter start(){
        Services.submitTask("log-writing", this::writeToLog);
        start = true;
        return this;
    }

    /**
     * Constantly polls the queue, and writes whatever is in the queue to the log file.
     * If start = false, the infiniteloop will stop
     * @return the success value
     */
    public boolean writeToLog(){
        Services.submitTask("log-writer", () -> {
            while (start) {
                // See if there's anything in the queue
                if (queue.peek() != null) {
                    // If so, take the message
                    byte[] message = queue.poll();
                    try {
                        // And write it to the log file
                        writer.write(message);
                    } catch (IOException exception) {
                        LOG.exception(exception);
                    }
                }
            }
        });
        return true;
    }

    /**
     * Stops the recording and closes the outputstream.
     */
    public void close(){
        // Stop the recording
        start = false;
        try {
            // close the outputstream
            writer.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Attaches the compatible pipelines for the {@link LogRefereeConsumer} and {@link LogWrapperConsumer}
     */
    public void attachToCompatiblePipelines(){
        refereeWriter.attachToCompatiblePipelines();
        detectionWriter.attachToCompatiblePipelines();
    }

    /**
     * @return the filename in the format of recordingLocation/yyyy-MM-dd-HHmmss_ally_enemy.log
     */
    public static String getCurrentFileName(){
        Optional<Team> allyTeam = Models.<Team>get("team A");
        Optional<Team> opponentTeam = Models.<Team>get("team O");
        Optional<Settings> settings = Models.<Settings>get("settings");
        String logFolder = "";
        if(settings.isPresent())
            logFolder = settings.get().getRecordingsFolder();

        return logFolder + "/" +
                new SimpleDateFormat("yyyy-MM-dd-HHmmss").format(Calendar.getInstance().getTime()) + "_" +
                (allyTeam.isPresent() ? allyTeam.get().getTeamName() : "ally") + "_" +
                (opponentTeam.isPresent() ? opponentTeam.get().getTeamName() : "opponent") + ".log";
    }

    /**
     * {@link AbstractConsumer A consumer} that consumes {@link RefereePacket RefereePackets} and writes them to
     * the {@link LogWriter}.
     */
    private class LogRefereeConsumer extends AbstractConsumer<RefereePacket> {
        /** The {@link LogWriter} that writes the data to a *.log file */
        private LogWriter writer;

        /**
         * Constucts a {@link AbstractConsumer Consumer} that consumes {@link RefereePacket RefereePackets}
         * @param writer the {@link LogWriter} used to write to the *.log files
         */
        public LogRefereeConsumer(LogWriter writer){
            super("logwriter-referee");
            this.writer = writer;
        }

        /**
         * Consumes the {@link RefereePacket packet} and writes it to the log.
         * @param pipelinePacket
         *            The PipelinePacket to be consumed.
         * @return the success value
         */
        @Override
        public boolean consume(RefereePacket pipelinePacket) {
            try {
                // Create a "Byte buffer"
                ByteArrayOutputStream arrayWriter = new ByteArrayOutputStream();
                // Add the timestamp
                arrayWriter.write(ByteBuffer.allocate(Long.SIZE / Byte.SIZE).putLong(System.nanoTime()).array());
                // Add the refbox message type
                arrayWriter.write(ByteBuffer.allocate(Integer.SIZE / Byte.SIZE).putInt(MESSAGE_SSL_REFBOX_2013).array());

                // Read the Refereepacket and change it to a byte array
                byte[] array = pipelinePacket.read().toByteArray();
                // Write the length to the log file
                arrayWriter.write(ByteBuffer.allocate(Integer.SIZE / Byte.SIZE).putInt(array.length).array());
                // Write the byte value of the RefereePacket
                arrayWriter.write(array);

                // Write the entire packet to the queue
                writer.addToQueue(arrayWriter.toByteArray());
            }catch (IOException exception){
                LOG.exception(exception);
            }
            return true;
        }
    }

    /**
     * {@link AbstractConsumer A consumer} that consumes {@link WrapperPacket WrapperPackets} and writes them to
     * the {@link LogWriter}.
     */
    private class LogWrapperConsumer extends AbstractConsumer<WrapperPacket> {
        /** The {@link LogWriter} that writes the data to a *.log file */
        private LogWriter writer;

        /**
         * Constucts a {@link AbstractConsumer Consumer} that consumes {@link WrapperPacket WrapperPackets}
         * @param writer the {@link LogWriter} used to write to the *.log files
         */
        public LogWrapperConsumer(LogWriter writer){
            super("logwriter-detection");
            this.writer = writer;
        }

        /**
         * Consumes the {@link WrapperPacket packet} and writes it to the log.
         * @param pipelinePacket
         *            The PipelinePacket to be consumed.
         * @return the success value
         */
        @Override
        public boolean consume(WrapperPacket pipelinePacket) {
            try {
                // Create a "Byte Buffer"
                ByteArrayOutputStream arrayWriter = new ByteArrayOutputStream();
                // Add the timestamp
                arrayWriter.write(ByteBuffer.allocate(Long.SIZE / Byte.SIZE).putLong(System.nanoTime()).array());
                // Add the vision message type
                arrayWriter.write(ByteBuffer.allocate(Integer.SIZE / Byte.SIZE).putInt(MESSAGE_SSL_VISION_2010).array());

                // Turn the packet into a byte array
                byte[] array = pipelinePacket.read().toByteArray();
                // Write the length of the byte array
                arrayWriter.write(ByteBuffer.allocate(Integer.SIZE / Byte.SIZE).putInt(array.length).array());
                // Write the byte array version of the packet
                arrayWriter.write(array);

                // Add the packet to the queue
                writer.addToQueue(arrayWriter.toByteArray());
            }catch (IOException exception){
                LOG.exception(exception);
            }
            return true;
        }
    }
}

