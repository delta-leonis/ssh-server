package org.ssh.expressions;

import org.ssh.expressions.tokens.FunctionToken;
import org.ssh.expressions.tokens.OperatorToken;
import org.ssh.managers.manager.Services;
import org.ssh.util.Logger;

import java.util.*;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * The Class RegularLanguage.
 * <p>
 * This class represents a regular language that can handle infix notation, customer operators, and
 * function operators (such as brackets and parenthses) on arbitrary words of type O. The language is modeled using the
 * shunting-yard algorithm to go from infix-notation to postfix-notation, which is then converted
 * to a list of linearly concatenated words. The language provides an evaluation method which executes
 * the supplied function and operator lambda's and returns an object of the type O.
 * <p>
 * http://hackingoff.com/compilers/regular-expression-to-nfa-dfa
 * http://www.cs.utexas.edu/~EWD/MCReps/MR35.PDF
 * http://www.personal.kent.edu/~rmuhamma/Compilers/MyCompiler/NFAtoDFA.htm
 *
 * @param <O> The type of object generated by the supplied concatenation operation.
 * @author Rimon Oz
 */
public class RegularLanguage<O> {

    /**
     * A list of operators supported by this language.
     * {@see OperatorToken}
     */
    private List<OperatorToken<O>> operatorList;
    /**
     * A list of functions supported by this language.
     * {@see FunctionToken}
     */
    private List<FunctionToken<O>> functionList;
    /**
     * The structure of the language represented as a regex that can be used
     * to split expressions in this language.
     */
    private String languageStructure;
    /**
     * The concatenation operator used by the language
     */
    private String concatenationOperator;

    /**
     * The concatenation operation used by the language.
     */
    private BiFunction<O, O, List<O>> concatenationOperation;

    /**
     * The operation that resolves a String representation
     * of a word in the language to the actual Object it refers to.
     */
    private Function<String, O> resolver;

    /**
     * Constructs a new RegularLanguage with the supplied resolving operation.
     *
     * @param resolver The operation that resolves a String representation to the actual Object it refers to.
     */
    public RegularLanguage(Function<String, O> resolver) {
        this.resolver = resolver;
    }

    // respective logger
    private static final Logger LOG      = Logger.getLogger();

    /**
     * Adds a concatenation operator to the language. A concatenation operator is used for chaining
     * tokens together to form a new token.
     *
     * @param concatenationOperator  The String representation of the concatenation operator.
     * @param concatenationOperation The concatenation operation as a lambda which takes two arguments and returns a list.
     * @return                       The result of the concatenation operation.
     */
    public RegularLanguage<O> addConcatenator(String concatenationOperator, BiFunction<O, O, List<O>> concatenationOperation) {
        // set attributes
        this.operatorList = new ArrayList<>();
        this.functionList = new ArrayList<>();
        this.concatenationOperator = concatenationOperator;
        this.setConcatenationOperation(concatenationOperation);

        // for method chaining
        return this;
    }

    /**
     * Adds an operator to the language. An operator takes two arguments and returns one (eg. for the operator * we have 2*4 = 8).
     * {@see OperatorToken}
     *
     * @param operatorToken      The string representation of the operator.
     * @param direction          Whether the operator is left-associative (eg. multiplication) or right associative (eg. exponentiation)
     * @param operatorPrecedence An integer indicating the precedence level of the operator.
     * @param transferFunction   The operator's operation represented by a BiFunction that takes two arguments and returns one.
     * @return Returns this object to support method chaining.
     */
    public RegularLanguage<O> addOperator(String operatorToken,
                                          boolean direction,
                                          int operatorPrecedence,
                                          BiFunction<O, O, List<O>> transferFunction) {
        // add the operator to the list
        this.operatorList.add(new OperatorToken<>(operatorToken, direction, operatorPrecedence, transferFunction));

        // for method chaining
        return this;
    }

    /**
     * Adds a function to the language. A function can take multiple arguments and returns one (eg. for the function log we have log(10, 100) = 2).
     *
     * @param functionToken     The string representation of the function.
     * @param transferFunction  The function's operation represented by a Function that takes a list of arguments and returns one.
     * @return Returns this object to support method chaining.
     */
    public RegularLanguage<O> addFunction(String functionToken, Function<List<String>, List<O>> transferFunction) {
        // add the operator to the list
        this.functionList.add(new FunctionToken<>(functionToken, transferFunction));

        // for method chaining
        return this;
    }

    /**
     * Builds the regex that tokenizes expressions in this language.
     *
     * @return Returns this object to support method chaining.
     */
    public RegularLanguage<O> build() {
        // tokenize the pattern
        this.languageStructure = "("
                // first create matchers for all grouping operators
                .concat(RegularLanguage.tokenToMatcher(this.concatenationOperator) + "|")
                .concat(RegularLanguage.tokenToMatcher("(") + "|")
                .concat(RegularLanguage.tokenToMatcher(")") + "|")
                .concat(RegularLanguage.tokenToMatcher("[") + "|")
                .concat(RegularLanguage.tokenToMatcher("]"))
                // and for all operators
                .concat(this.operatorList.stream()
                        .map(Token::getSymbol)
                        .reduce("", (leftElement, rightElement) ->
                                leftElement.concat("|").concat(RegularLanguage.tokenToMatcher(rightElement))))
                // and for all functions
                .concat(this.functionList.stream()
                        .map(Token::getSymbol)
                        .reduce("", (leftElement, rightElement) ->
                                leftElement.concat("|").concat(RegularLanguage.tokenToMatcher(rightElement))))
                .concat(")");

        // for method chaining
        return this;
    }

    /**
     * Takes a string representation of the token and returns a regex that allows for splitting on that token
     * without deletion.
     *
     * @param token The string representation of the token.
     * @return The regex that allows for splitting on the supplied token without deletion.
     */
    private static String tokenToMatcher(String token) {
        // this regex uses lookahead and lookbehind to keep the
        // operator in the list of matched tokens
        return String.format("((?<=%1$s)|(?=%1$s))", Pattern.quote(token));
    }

    /**
     * Tokenizes the supplied string into an ArrayDeque<Token>. This method takes care of typing the tokens
     * to FunctionToken, OperatorToken, and regular Token.
     *
     * @param pattern The string to be tokenized.
     * @return An ArrayDeque<Token> containing all the tokens in the string.
     */
    private Deque<Token<O>> tokenize(String pattern) {
        // return the tokenization
        return new ArrayDeque<>(Stream.of(pattern.split(this.languageStructure)).map(token -> {
            // get the type and create the token accordingly
            switch (this.getTypeOf(token)) {
                case "o":
                    return this.getOperator(token);
                case "f":
                    return this.getFunction(token);
                default:
                    return new Token<O>(this.getTypeOf(token), token);
            }
            // the ArrayDeque-constructor takes a list
        }).collect(Collectors.toList()));
    }

    /**
     * Compiles a supplied pattern into a language. The compilation consists of tokenization followed by
     * the shunt-yard algorithm.
     *
     * @param pattern The pattern which is to be compiled.
     * @return Returns this object to support method chaining.
     */
    public Deque<Token<O>> toPostFix(String pattern) {
        // check if there's any operators in the first place
        if (this.operatorList.isEmpty()) {
            RegularLanguage.LOG.fine("A regular language encountered an empty stack.");
            return new ArrayDeque<>();
        }

        // tokenize the string
        ArrayDeque<Token<O>> tokenStack = (ArrayDeque<Token<O>>) this.tokenize(pattern);

        // to postfix
        ArrayDeque<Token<O>> operatorStack = new ArrayDeque<>();
        ArrayDeque<Token<O>> outputStack = new ArrayDeque<>();

        // SHUNTING YARD ALGORITHM
        while (!tokenStack.isEmpty()) {
            // get the next token
            Token<O> token = tokenStack.pop();

            // depending on the type
            switch (token.getType()) {
                case "c": // its a concatenation operator
                    token = new OperatorToken<>(this.concatenationOperator, true, 1, this.concatenationOperation);
                case "o": // it's an operator
                    // turn it into an operator
                    OperatorToken<O> operator = (OperatorToken<O>) token;
                    // while there's another operator at the TopSection of the stack and either
                    // the first operator is left-associative and has precedence <= the precedence of the second operator
                    // or the first operator is right-associative and has precedence < the precedence of the second operator
                    while (!operatorStack.isEmpty() && "o".equals(operatorStack.peek().getType())
                            && ((!operator.getDirection() && operator.getPrecedence() <= ((OperatorToken<O>) operatorStack.peek()).getPrecedence())
                            || operator.getDirection() && operator.getPrecedence() < ((OperatorToken<O>) operatorStack.peek()).getPrecedence())) {
                        // pop the operator from the operator-stack and push it onto the output-stack
                        outputStack.push(operatorStack.pop());
                    }
                    // push the operator onto the operator stack
                    operatorStack.push(operator);
                    break;
                case "(": // it's a left parenthesis
                    // push it onto the operator stack
                    operatorStack.push(token);
                    break;
                case ")": // it's a right parenthesis
                    // until there's a left parenthesis at the TopSection of the operator stack
                    while (!"(".equals(operatorStack.peek().getType())) {
                        // pop operators from the operator stack and push them onto the outputstack
                        outputStack.push(operatorStack.pop());
                    }
                    // pop the left parenthesis from the operatorstack and make it disappear
                    operatorStack.pop();
                    // if there's a function at the TopSection of the operator-stack
                    if (!operatorStack.isEmpty() && "f".equals(operatorStack.peek().getType())) {
                        // pop it off and push it onto the output-stack
                        outputStack.push(operatorStack.pop());
                    }
                    break;
                case "f": // it's a function
                    // push it onto the operator stack
                    operatorStack.push(token);
                    break;
                default: // it's a word
                    // push it onto the output-stack
                    outputStack.push(token);
                    break;
            }

        }
        // until the operator-stack is empty
        while (!operatorStack.isEmpty()) {
            // if there's a left parenthesis or a right parenthesis at the TopSection of the operator-stack
            // there's mismatched parentheses
            if ("(".equals(operatorStack.peek().getSymbol()) || ")".equals(operatorStack.peek().getSymbol())) {
                RegularLanguage.LOG.fine("A regular language encountered a mismatched parenthesis.");
            }
            // pop operators off of the operator-stack and push them onto the output-stack
            outputStack.push(operatorStack.pop());
        }

        // return the postfix representation of the expression
        return outputStack;
    }

    /**
     * Evaluates the given pattern and returns a list of all possible results generated by the pattern.
     * @param pattern   The pattern to be evaluated.
     * @return          A list of results generated by the evaluation.
     */
    public List<O> evaluate(String pattern) {
        // tokenize the input
        ArrayDeque<Token<O>> tokenStack = (ArrayDeque<Token<O>>) this.toPostFix(pattern);

        if (tokenStack.size() == 1) {
            Token<O> onlyToken = tokenStack.pop();
            return Stream.of(onlyToken.hasMeaning()  ? onlyToken.getMeaning()  : this.resolveMeaning(onlyToken)).collect(Collectors.toList());
        }
        // create a stack for the outputs
        ArrayList<ArrayDeque<Token<O>>> outputStacks = new ArrayList<>();
        // insert the first output stack
        outputStacks.add(new ArrayDeque<>());

        // while there's still input left to be consumed 
        while (!tokenStack.isEmpty()) {
            // take a token
            Token<O> token = tokenStack.removeLast();

            // check its type
            switch (token.getType()) {
                // if it's a word
                case "w":
                    // then add it to each stack
                    outputStacks.forEach(stack -> stack.push(token));
                    break;
                // if it's an operator
                case "o":
                    // convert the token to an operator
                    OperatorToken<O> operator = (OperatorToken<O>) token;
                    // transform the outputstacks
                    outputStacks = (ArrayList<ArrayDeque<Token<O>>>) outputStacks.stream().map(outputStack -> {
                        // check to make sure there's enough tokens in the stack for the operator to operate on
                        if (outputStack.size() < 2) {
                            RegularLanguage.LOG.fine("A regular language encountered missing arguments to an operator.");
                        }
                        // pop the two members and operator
                        Token<O> secondMember = outputStack.pop();
                        Token<O> firstMember = outputStack.pop();
                        // apply the operator
                        List<O> outputs = operator.apply(
                                firstMember.hasMeaning()  ? firstMember.getMeaning()  : this.resolveMeaning(firstMember),
                                secondMember.hasMeaning() ? secondMember.getMeaning() : this.resolveMeaning(secondMember));

                        // for every output in the list
                        return outputs.stream().map(output -> {
                            // create a new stack  
                            ArrayDeque<Token<O>> newStack = new ArrayDeque<>(outputStack);
                            // and add the new output
                            newStack.push(new Token<>(output));
                            // and save the stack
                            return newStack;
                        }).collect(Collectors.toList());
                        // turn all newly generated lists of stacks into a single list of outputStacks
                    }).flatMap(Collection::stream).collect(Collectors.toList());
                    break;
                case "f":
                    // convert the token to an operator
                    FunctionToken<O> function = (FunctionToken<O>) token;
                    // transform the outputstacks
                    outputStacks = (ArrayList<ArrayDeque<Token<O>>>) outputStacks.stream().map(outputStack -> {
                        ArrayList<String> argumentList = new ArrayList<>();
                        // get all the function arguments
                        // pop a token off the stack
                        Token<O> candidateToken = outputStack.pop();
                        // if it's not a word then it's not an argument
                        if (!Objects.equals(candidateToken.getType(), "w")) {
                            RegularLanguage.LOG.fine("A regular language encountered a syntax error.");
                        }
                        // add it to the list of arguments
                        Collections.addAll(argumentList, candidateToken.getSymbol().split(","));
                        // apply the function
                        List<O> outputs = function.apply(argumentList);

                        // for every output in the list
                        return outputs.stream().map(output -> {
                            // create a new stack  
                            ArrayDeque<Token<O>> newStack = new ArrayDeque<>(outputStack);
                            // and add the new output
                            newStack.push(new Token<>(output));
                            // and save the stack
                            return newStack;
                        }).collect(Collectors.toList());
                        // turn all newly generated lists of stacks into a single list of outputStacks
                    }).flatMap(Collection::stream).collect(Collectors.toList());
                    break;
            }
        }

        return outputStacks.stream().map(list -> list.getFirst().getMeaning()).distinct().collect(Collectors.toList());
    }

    private O resolveMeaning(Token<O> firstMember) {
        return this.resolver.apply(firstMember.getSymbol());
    }

    /**
     * Returns the type of the token as it is recognized by the language. The return-value will
     * be one of "(", ")", "s" for separator, "w" for word, "f" for function, and "o" for operator.
     *
     * @param token The token to be typed.
     * @return The type of the token as a string.
     */
    protected String getTypeOf(String token) {
        // if it's a parenthesis then simply return it
        if ("(".equals(token) || ")".equals(token)) {
            return token;
        }
        // if it's the concatenation operator
        else if (this.concatenationOperator.equals(token)) {
            return "c";
        }
        // if the token is in the operator list
        else if (this.operatorList.stream().filter(operator -> operator.getSymbol().equals(token)).findFirst()
                .isPresent()) {
            return "o";
        }
        // if the token is in the function list
        else if (this.functionList.stream().filter(operator -> operator.getSymbol().equals(token)).findFirst()
                .isPresent()) {
            return "f";
        }
        // otherwise it's a word
        return "w";
    }

    /**
     * Returns an OperatorToken if the supplied string is the string representation of an operator in the language, null otherwise.
     *
     * @param operatorSymbol The string representation of the operator.
     * @return The operator as an OperatorToken.
     */
    public OperatorToken<O> getOperator(String operatorSymbol) {
        return this.operatorList.stream().filter(operator -> operator.getSymbol().equals(operatorSymbol)).findFirst()
                .get();
    }

    /**
     * Returns a FunctionToken if the supplied string is the string representation of a function in the language, null otherwise.
     *
     * @param functionSymbol The string representation of the function.
     * @return The function as an FunctionToken.
     */
    public FunctionToken<O> getFunction(String functionSymbol) {
        return this.functionList.stream().filter(function -> function.getSymbol().equals(functionSymbol)).findFirst()
                .get();
    }

    /**
     * Sets the concatenation operation to the supplied lambda.
     *
     * @param concatenationOperation The concatenation operation to be set for this language.
     */
    public void setConcatenationOperation(BiFunction<O, O, List<O>> concatenationOperation) {
        this.concatenationOperation = concatenationOperation;
    }
}
